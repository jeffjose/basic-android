/* App.svelte generated by Svelte v4.2.18 */
import {
	SvelteComponent,
	add_flush_callback,
	bind,
	binding_callbacks,
	create_component,
	destroy_component,
	detach,
	init,
	insert,
	mount_component,
	safe_not_equal,
	set_data,
	space,
	text,
	transition_in,
	transition_out
} from "svelte/internal";

import "svelte/internal/disclose-version";
import Two from './Two.svelte';

function create_fragment(ctx) {
	let t0;
	let t1;
	let two;
	let updating_name;
	let current;

	function two_name_binding(value) {
		/*two_name_binding*/ ctx[1](value);
	}

	let two_props = {};

	if (/*name*/ ctx[0] !== void 0) {
		two_props.name = /*name*/ ctx[0];
	}

	two = new Two({ props: two_props });
	binding_callbacks.push(() => bind(two, 'name', two_name_binding));

	return {
		c() {
			t0 = text(/*name*/ ctx[0]);
			t1 = space();
			create_component(two.$$.fragment);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			mount_component(two, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*name*/ 1) set_data(t0, /*name*/ ctx[0]);
			const two_changes = {};

			if (!updating_name && dirty & /*name*/ 1) {
				updating_name = true;
				two_changes.name = /*name*/ ctx[0];
				add_flush_callback(() => updating_name = false);
			}

			two.$set(two_changes);
		},
		i(local) {
			if (current) return;
			transition_in(two.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(two.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
			}

			destroy_component(two, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let name = 1;

	function two_name_binding(value) {
		name = value;
		$$invalidate(0, name);
	}

	return [name, two_name_binding];
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default App;
